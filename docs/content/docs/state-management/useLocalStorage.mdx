---
title: useLocalStorage
description: Persist and sync state with localStorage for reliable client-side storage in React.
tags: ["react", "hooks", "state", "storage", "localStorage"]
status: stable
version: 2.0.0
lastUpdated: "2025-09-12"
author: "OpenHooks Team"
category: "state-management"
difficulty: beginner
bundle_size: "~0.7kb"
dependencies: ["react"]
---

import { Tabs, Tab } from "fumadocs-ui/components/tabs";
import {
  Tabs as ShadcnTabs,
  TabsContent as ShadcnTabsContent,
  TabsList as ShadcnTabsList,
  TabsTrigger as ShadcnTabsTrigger,
} from "@/components/ui/tabs";
import { AspectRatio } from "@/components/ui/aspect-ratio";
import { Callout } from "fumadocs-ui/components/callout";
import { TypeTable } from "fumadocs-ui/components/type-table";
import { Accordion, Accordions } from "fumadocs-ui/components/accordion";
import { Database, Save, RefreshCw, Shield } from "lucide-react";
import CodePreview from "@/components/CodePreview";
import { MetaInfo } from "@/components/MetaInfo";
import {
  BrowserCompatibility,
  PerformanceMetrics,
} from "@/components/CompatibilityTable";
import ExampleComponent from "@/examples/useLocalStorage/Example";

# useLocalStorage

> Persist and sync state with localStorage for reliable client-side storage in React.

<MetaInfo
  status="stable"
  version="2.0.0"
  bundleSize="~0.7kb"
  requires="React 16.8+"
/>

<ShadcnTabs defaultValue="Preview">
  <ShadcnTabsList>
    <ShadcnTabsTrigger value="Preview">Preview</ShadcnTabsTrigger>
    <ShadcnTabsTrigger value="Code">Code</ShadcnTabsTrigger>
  </ShadcnTabsList>
  <ShadcnTabsContent value="Preview">
    <AspectRatio ratio={16 / 9} className="w-full rounded-md border">
    <div className="w-full h-full overflow-auto p-4">
        <ExampleComponent />
    </div>
    </AspectRatio>
  </ShadcnTabsContent>
  <ShadcnTabsContent value="Code">
    <Tabs groupId="language" items={["TypeScript", "JavaScript"]}>
      <Tab value="TypeScript">

```tsx
import { useState } from "react";
import { useLocalStorage } from "@/hooks/useLocalStorage";

function UserPreferences() {
  const [theme, setTheme] = useLocalStorage("theme", "light");
  const [language, setLanguage] = useLocalStorage("language", "en");
  const [settings, setSettings] = useLocalStorage("settings", {
    notifications: true,
    autoSave: false,
  });

  return (
    <div className={`app ${theme}`}>
      <h2>User Preferences</h2>

      <div>
        <label>Theme:</label>
        <select value={theme} onChange={(e) => setTheme(e.target.value)}>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
          <option value="auto">Auto</option>
        </select>
      </div>

      <div>
        <label>Language:</label>
        <select value={language} onChange={(e) => setLanguage(e.target.value)}>
          <option value="en">English</option>
          <option value="es">Spanish</option>
          <option value="fr">French</option>
        </select>
      </div>

      <div>
        <label>
          <input
            type="checkbox"
            checked={settings.notifications}
            onChange={(e) =>
              setSettings({
                ...settings,
                notifications: e.target.checked,
              })
            }
          />
          Enable Notifications
        </label>
      </div>
    </div>
  );
}
```

      </Tab>
      <Tab value="JavaScript">

```jsx
import { useState } from "react";
import { useLocalStorage } from "@/hooks/useLocalStorage";

function UserPreferences() {
  const [theme, setTheme] = useLocalStorage("theme", "light");
  const [language, setLanguage] = useLocalStorage("language", "en");
  const [settings, setSettings] = useLocalStorage("settings", {
    notifications: true,
    autoSave: false,
  });

  return (
    <div className={`app ${theme}`}>
      <h2>User Preferences</h2>

      <div>
        <label>Theme:</label>
        <select value={theme} onChange={(e) => setTheme(e.target.value)}>
          <option value="light">Light</option>
          <option value="dark">Dark</option>
          <option value="auto">Auto</option>
        </select>
      </div>

      <div>
        <label>Language:</label>
        <select value={language} onChange={(e) => setLanguage(e.target.value)}>
          <option value="en">English</option>
          <option value="es">Spanish</option>
          <option value="fr">French</option>
        </select>
      </div>

      <div>
        <label>
          <input
            type="checkbox"
            checked={settings.notifications}
            onChange={(e) =>
              setSettings({
                ...settings,
                notifications: e.target.checked,
              })
            }
          />
          Enable Notifications
        </label>
      </div>
    </div>
  );
}
```

      </Tab>
    </Tabs>

  </ShadcnTabsContent>
</ShadcnTabs>

## Installation

<ShadcnTabs defaultValue="CLI">
  <ShadcnTabsList>
    <ShadcnTabsTrigger value="CLI">CLI</ShadcnTabsTrigger>
    <ShadcnTabsTrigger value="Manual">Manual</ShadcnTabsTrigger>
  </ShadcnTabsList>
  <ShadcnTabsContent value="CLI">
    <Tabs groupId="package-manager" items={["npm", "yarn", "pnpm"]}>
      <Tab value="npm">

```bash
npx open-hook add useLocalStorage
```

      </Tab>
      <Tab value="yarn">

```bash
yarn dlx open-hook add useLocalStorage
```

      </Tab>
      <Tab value="pnpm">

```bash
pnpm dlx open-hook add useLocalStorage
```

      </Tab>
    </Tabs>

  </ShadcnTabsContent>
  <ShadcnTabsContent value="Manual">
    <Callout type="info">
      No external dependencies needed - just React 16.8+
    </Callout>
    <Tabs groupId="language" items={["TypeScript", "JavaScript"]}>
      <Tab value="TypeScript">

```ts title="hooks/useLocalStorage.ts"
import { useState, useEffect } from "react";

export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void] {
  // Get from local storage then parse stored json or return initialValue
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === "undefined") {
      return initialValue;
    }
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const setValue = (value: T | ((val: T) => T)) => {
    try {
      // Allow value to be a function so we have the same API as useState
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;

      setStoredValue(valueToStore);

      // Save to local storage
      if (typeof window !== "undefined") {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.warn(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue];
}
```

      </Tab>
      <Tab value="JavaScript">

```js title="hooks/useLocalStorage.js"
import { useState, useEffect } from "react";

export function useLocalStorage(key, initialValue) {
  // Get from local storage then parse stored json or return initialValue
  const [storedValue, setStoredValue] = useState(() => {
    if (typeof window === "undefined") {
      return initialValue;
    }
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const setValue = (value) => {
    try {
      // Allow value to be a function so we have the same API as useState
      const valueToStore =
        value instanceof Function ? value(storedValue) : value;

      setStoredValue(valueToStore);

      // Save to local storage
      if (typeof window !== "undefined") {
        window.localStorage.setItem(key, JSON.stringify(valueToStore));
      }
    } catch (error) {
      console.warn(`Error setting localStorage key "${key}":`, error);
    }
  };

  return [storedValue, setValue];
}
```

      </Tab>
    </Tabs>

  </ShadcnTabsContent>
</ShadcnTabs>

## API Reference

### Parameters

<TypeTable
  type={{
    key: {
      type: "string",
      description: "The localStorage key to use for storing the value",
    },
    initialValue: {
      type: "T",
      description: "Initial value to use if nothing is stored in localStorage",
    },
  }}
/>

### Returns

<TypeTable
  type={{
    value: {
      type: "T",
      description: "The current value from localStorage or initial value",
    },
    setValue: {
      type: "(value: T | ((val: T) => T)) => void",
      description:
        "Function to update the value and persist it to localStorage",
    },
  }}
/>

## TypeScript Signature

```ts
function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((val: T) => T)) => void];
```

## Advanced Usage Examples

<Tabs groupId="usage" items={["Basic Usage", "Complex Objects", "Form Persistence", "Multi-Tab Sync"]}>
  <Tab value="Basic Usage">

```tsx
// Simple string value
const [username, setUsername] = useLocalStorage("username", "");

// Boolean preference
const [darkMode, setDarkMode] = useLocalStorage("darkMode", false);

// Number setting
const [fontSize, setFontSize] = useLocalStorage("fontSize", 16);
```

  </Tab>
  <Tab value="Complex Objects">

```tsx
interface UserProfile {
  name: string;
  email: string;
  preferences: {
    theme: string;
    language: string;
  };
}

const [profile, setProfile] = useLocalStorage<UserProfile>("userProfile", {
  name: "",
  email: "",
  preferences: {
    theme: "light",
    language: "en",
  },
});

// Update nested properties
const updateTheme = (newTheme: string) => {
  setProfile((prev) => ({
    ...prev,
    preferences: {
      ...prev.preferences,
      theme: newTheme,
    },
  }));
};
```

  </Tab>
  <Tab value="Form Persistence">

```tsx
interface FormData {
  title: string;
  content: string;
  tags: string[];
}

function DraftEditor() {
  const [formData, setFormData] = useLocalStorage<FormData>("draft", {
    title: "",
    content: "",
    tags: [],
  });

  const handleSubmit = () => {
    // Submit form
    submitPost(formData);

    // Clear draft after successful submission
    setFormData({
      title: "",
      content: "",
      tags: [],
    });
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        value={formData.title}
        onChange={(e) =>
          setFormData((prev) => ({
            ...prev,
            title: e.target.value,
          }))
        }
        placeholder="Title"
      />
      {/* More form fields */}
    </form>
  );
}
```

  </Tab>
  <Tab value="Multi-Tab Sync">

```tsx
function useLocalStorageWithSync<T>(key: string, initialValue: T) {
  const [value, setValue] = useLocalStorage(key, initialValue);

  useEffect(() => {
    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === key && e.newValue !== null) {
        setValue(JSON.parse(e.newValue));
      }
    };

    window.addEventListener("storage", handleStorageChange);
    return () => window.removeEventListener("storage", handleStorageChange);
  }, [key, setValue]);

  return [value, setValue];
}
```

  </Tab>
</Tabs>

## Best Practices

<Callout type="tip">
Choose appropriate storage strategies based on your use case:

```tsx
// Theme preferences - simple and persistent
const [theme, setTheme] = useLocalStorage("app-theme", "light");

// User settings - complex object with defaults
const [settings, setSettings] = useLocalStorage("user-settings", {
  notifications: true,
  autoSave: true,
  language: "en",
});

// Form drafts - auto-save with cleanup
const [draft, setDraft] = useLocalStorage("post-draft", {
  title: "",
  content: "",
});
```

</Callout>

### Security & Performance Guidelines

- **🔒 Data Security**: Never store sensitive data like passwords or tokens
- **📦 Size Limits**: Keep data under 5MB (localStorage limit varies by browser)
- **🚀 Performance**: Use for small to medium-sized data only
- **🔄 Serialization**: Ensure data is JSON-serializable

### Do's and Don'ts

- ✅ Use for user preferences and settings
- ✅ Store theme, language, and UI state
- ✅ Implement form draft functionality
- ✅ Cache non-sensitive application data
- ❌ Don't store passwords or authentication tokens
- ❌ Avoid storing large files or images
- ❌ Don't rely on localStorage for critical application state
- ❌ Avoid circular references in objects

## Performance Metrics

<PerformanceMetrics
  metrics={[
    {
      metric: "Bundle Size",
      value: "~0.7kb",
      description: "Minified + gzipped",
    },
    {
      metric: "Persistence",
      value: "Permanent",
      description: "Survives browser restarts",
    },
    {
      metric: "Sync Speed",
      value: "Instant",
      description: "Immediate localStorage updates",
    },
    {
      metric: "Storage Limit",
      value: "~5-10MB",
      description: "Browser-dependent limit",
    },
  ]}
/>

## Browser Compatibility

<BrowserCompatibility
  browsers={[
    { name: "Chrome (latest)", supported: true, notes: "Full support" },
    { name: "Firefox (latest)", supported: true, notes: "Full support" },
    { name: "Safari (latest)", supported: true, notes: "Full support" },
    { name: "Edge (latest)", supported: true, notes: "Full support" },
    { name: "IE 11", supported: true, notes: "Basic support" },
    { name: "Node.js", supported: false, notes: "SSR-safe with fallback" },
  ]}
/>

## Use Cases

### <Database className="inline w-4 h-4 mr-2" /> Theme & Preferences

Store user interface preferences like theme, language, and layout settings.

### <Save className="inline w-4 h-4 mr-2" /> Form Draft Saving

Automatically save form data to prevent data loss on page refresh.

### <RefreshCw className="inline w-4 h-4 mr-2" /> Shopping Cart Persistence

Maintain shopping cart contents across browser sessions.

### <Shield className="inline w-4 h-4 mr-2" /> Application Settings

Store non-sensitive application configuration and user customizations.

## Accessibility

<Callout type="info" title="Accessibility Considerations">
  - localStorage doesn't directly impact accessibility - Use for storing
  accessibility preferences (font size, contrast settings) - Ensure UI updates
  from localStorage are announced to screen readers - Consider high contrast and
  reduced motion preferences
</Callout>

## Troubleshooting

<Accordions>
<Accordion title="Value not persisting after page reload">

**Solution:** Check that the key is unique and not being overwritten elsewhere. Verify localStorage is available:

```tsx
// Check localStorage availability
if (typeof Storage !== "undefined") {
  // localStorage is available
} else {
  // No web storage support
}
```

</Accordion>

<Accordion title="JSON parsing errors in console">

**Solution:** Ensure you're only storing JSON-serializable data:

```tsx
// ❌ Won't work - functions aren't serializable
const [state, setState] = useLocalStorage("key", {
  data: "value",
  callback: () => console.log("test"),
});

// ✅ Works - plain data objects
const [state, setState] = useLocalStorage("key", {
  data: "value",
  timestamp: Date.now(),
});
```

</Accordion>

<Accordion title="localStorage quota exceeded">

**Solution:** Monitor storage usage and implement cleanup:

```tsx
// Check localStorage usage
const getStorageSize = () => {
  let total = 0;
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      total += localStorage[key].length + key.length;
    }
  }
  return total;
};

// Clear old data if needed
if (getStorageSize() > 4000000) {
  // ~4MB
  // Remove old entries
  localStorage.removeItem("old-key");
}
```

</Accordion>

<Accordion title="SSR/Next.js hydration issues">

**Solution:** Handle server-side rendering properly:

```tsx
// Use dynamic import for client-only hooks
const [mounted, setMounted] = useState(false);
const [value, setValue] = useLocalStorage("key", "default");

useEffect(() => {
  setMounted(true);
}, []);

if (!mounted) {
  return <div>Loading...</div>;
}

return <div>{value}</div>;
```

</Accordion>
</Accordions>

## Internals

<Callout type="info" title="How It Works">
The hook initializes state by reading from localStorage on mount, parsing the JSON value, and falling back to the initial value if parsing fails or localStorage is unavailable. When the value changes, it immediately updates both React state and localStorage using JSON.stringify().

The hook includes SSR safety by checking for `window` availability and graceful error handling for localStorage quota exceeded or parsing errors.

</Callout>

## Testing Example

```ts
import { renderHook, act } from "@testing-library/react";
import { useLocalStorage } from "./useLocalStorage";

// Mock localStorage
const localStorageMock = {
  getItem: jest.fn(),
  setItem: jest.fn(),
  removeItem: jest.fn(),
  clear: jest.fn(),
};
global.localStorage = localStorageMock as any;

describe("useLocalStorage", () => {
  beforeEach(() => {
    localStorageMock.getItem.mockClear();
    localStorageMock.setItem.mockClear();
  });

  it("should return initial value when localStorage is empty", () => {
    localStorageMock.getItem.mockReturnValue(null);
    const { result } = renderHook(() => useLocalStorage("test-key", "default"));

    expect(result.current[0]).toBe("default");
  });

  it("should persist value to localStorage", () => {
    const { result } = renderHook(() => useLocalStorage("test-key", "default"));

    act(() => {
      result.current[1]("new-value");
    });

    expect(localStorageMock.setItem).toHaveBeenCalledWith(
      "test-key",
      JSON.stringify("new-value")
    );
    expect(result.current[0]).toBe("new-value");
  });

  it("should handle function updates", () => {
    const { result } = renderHook(() => useLocalStorage("test-key", 0));

    act(() => {
      result.current[1]((prev) => prev + 1);
    });

    expect(result.current[0]).toBe(1);
  });
});
```

## FAQ

<Accordions>
<Accordion title="Does this work with server-side rendering?">

Yes, the hook is SSR-safe. It checks for `window` availability and returns the initial value during server-side rendering, then hydrates with the stored value on the client.

</Accordion>

<Accordion title="Can I store complex objects and arrays?">

Yes, as long as they're JSON-serializable. Avoid storing functions, dates (use timestamps), or objects with circular references.

```tsx
// ✅ Works
const [user, setUser] = useLocalStorage("user", {
  name: "John",
  settings: { theme: "dark" },
  tags: ["developer", "react"],
});

// ❌ Won't work
const [state, setState] = useLocalStorage("state", {
  callback: () => {}, // Functions not serializable
  date: new Date(), // Dates become strings
});
```

</Accordion>

<Accordion title="How do I sync data between tabs?">

localStorage changes trigger the `storage` event. You can listen for this event to sync data:

```tsx
useEffect(() => {
  const handleStorageChange = (e: StorageEvent) => {
    if (e.key === "your-key" && e.newValue) {
      // Update your state with the new value
      setValue(JSON.parse(e.newValue));
    }
  };

  window.addEventListener("storage", handleStorageChange);
  return () => window.removeEventListener("storage", handleStorageChange);
}, []);
```

</Accordion>

<Accordion title="What's the difference between localStorage and sessionStorage?">

- **localStorage**: Persists until explicitly cleared, survives browser restart
- **sessionStorage**: Cleared when tab closes, doesn't sync between tabs
- **useLocalStorage**: For long-term persistence
- **useSessionStorage**: For temporary, tab-specific data

</Accordion>
</Accordions>

## Related Hooks

- [useSessionStorage](./useSessionStorage) - Session-only storage alternative
- [useDebounce](./useDebounce) - Debounce localStorage updates
- [usePrevious](./usePrevious) - Track previous localStorage values

## Changelog

- **2.0.0** — Enhanced TypeScript support, added functional updates, improved SSR handling, better error handling, and comprehensive documentation
- **1.2.0** — Added support for complex objects and arrays with better JSON serialization
- **1.1.0** — Improved error handling and SSR compatibility
- **1.0.0** — Initial release with basic localStorage persistence functionality
